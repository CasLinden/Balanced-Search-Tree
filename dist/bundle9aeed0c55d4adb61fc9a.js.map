{"version":3,"file":"bundle9aeed0c55d4adb61fc9a.js","mappings":";;;;;;;;;;;;;;AAAO;AACP;AACA,+BAA+B,OAAO,EAAE,yBAAyB;AACjE;AACA,iBAAiB,OAAO,EAAE,yBAAyB,EAAE,UAAU;AAC/D;AACA,8BAA8B,OAAO,EAAE,yBAAyB;AAChE;AACA;;;;;;;UCRA;UACA;;UAEA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;;UAEA;UACA;;UAEA;UACA;UACA;;;;;WCtBA;WACA;WACA;WACA;WACA,yCAAyC,wCAAwC;WACjF;WACA;WACA;;;;;WCPA;;;;;WCAA;WACA;WACA;WACA,uDAAuD,iBAAiB;WACxE;WACA,gDAAgD,aAAa;WAC7D;;;;;;;;;;;;ACN4C;;;AAG5C;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yDAAW;;AAEX;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,OAAO;AACxC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,kCAAkC,OAAO,EAAE,yBAAyB;AACpE;AACA,oBAAoB,OAAO,EAAE,yBAAyB,EAAE,UAAU;AAClE;AACA,iCAAiC,OAAO,EAAE,yBAAyB;AACnE;AACA","sources":["webpack://webpack-template/./src/prettyprint.js","webpack://webpack-template/webpack/bootstrap","webpack://webpack-template/webpack/runtime/define property getters","webpack://webpack-template/webpack/runtime/hasOwnProperty shorthand","webpack://webpack-template/webpack/runtime/make namespace object","webpack://webpack-template/./src/index.js"],"sourcesContent":["export function prettyPrint(node, prefix = \"\", isLeft = true) {\n  if (node.right !== null) {\n    prettyPrint(node.right, `${prefix}${isLeft ? \"│   \" : \"    \"}`, false);\n  }\n  console.log(`${prefix}${isLeft ? \"└── \" : \"┌── \"}${node.data}`);\n  if (node.left !== null) {\n    prettyPrint(node.left, `${prefix}${isLeft ? \"    \" : \"│   \"}`, true);\n  }\n}\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","import { prettyPrint } from \"./prettyprint\";\n\n\nlet arr = [1, 7, 4, 23, 8, 9, 4, 3, 5, 7, 9, 67, 6345, 324];\nlet bst = Tree(arr);\n\n\nbst.insertNode(100)\nbst.insertNode(120)\nbst.insertNode(130);\nbst.insertNode(140);\nbst.deleteNode(8);\nbst.find(7)\nbst.levelOrder()\nconsole.log(bst.inOrder(bst.root))\nconsole.log(bst.preOrder(bst.root))\nconsole.log(bst.postOrder(bst.root))\nbst.depth(bst.find(7))\nbst.depth(bst.find(3))\nconsole.log(bst.height(bst.root));\nconsole.log(bst.isBalanced());\nlet rebalanced = bst.rebalance();\nprettyPrint(rebalanced);\n\nfunction Node(data, left = null, right = null) {\n  return {\n    data,\n    left,\n    right,\n  };\n}\n\nfunction Tree(InputArr) {\n  let arr = removeDuplicatesAndSort(InputArr);\n  let root = buildTree(arr, 0, arr.length - 1);\n\n  function removeDuplicatesAndSort(arr) {\n    const uniqueArr = [...new Set(arr)];\n    uniqueArr.sort(function (a, b) {\n      return a - b;\n    });\n    return uniqueArr;\n  }\n\n  function buildTree(arr, start, end) {\n    if (start > end) {\n      return null;\n    }\n    let mid = parseInt((start + end) / 2);\n    let node = Node(arr[mid]);\n    node.left = buildTree(arr, start, mid - 1);\n    node.right = buildTree(arr, mid + 1, end);\n    return node;\n  }\n\n  function insertNode(value, current = root) {\n    if (value < current.data) {\n      if (current.left === null) {\n        return (current.left = Node(value));\n      }\n      insertNode(value, current.left);\n    } else if (value > current.data) {\n      if (current.right === null) {\n        return (current.right = Node(value));\n      }\n      insertNode(value, current.right);\n    }\n  }\n\n  function deleteNode(value, current = root) {\n    if (current === null) return null;\n    if (value === root.data) return _deleteSwitch(current);\n    if (current.left?.data === value || current.right?.data === value) {\n      let oldNode = current.left?.data === value ? current.left : current.right;\n      return _deleteSwitch(oldNode, current);\n    }\n    if (value < current.data) {\n      return deleteNode(value, current.left);\n    } else if (value > current.data) {\n      return deleteNode(value, current.right);\n    }\n  }\n\n  function _deleteSwitch(oldNode, parent) {\n    if (!oldNode.left && !oldNode.right) {\n      _deleter(oldNode, parent);\n    } else if (\n      (!oldNode.left && oldNode.right) ||\n      (oldNode.left && !oldNode.right)\n    ) {\n      let child = oldNode.left ? oldNode.left : oldNode.right;\n      _deleter(oldNode, parent, child);\n    } else {\n      let successor = oldNode.right;\n      while (successor.left) {\n        successor = successor.left;\n      }\n      let successorData = successor.data;\n      deleteNode(successor.data);\n      oldNode.data = successorData;\n    }\n  }\n\n  function _deleter(oldNode, parent, newVal = null) {\n    if (parent.right === oldNode) {\n      parent.right = newVal;\n    } else {\n      parent.left = newVal;\n    }\n  }\n\n  function find(value, current = root) {\n    if (current === null) return null;\n    if (value === current.data) {\n      console.log(current);\n      return current;\n    }\n    if (value < current.data) {\n      return find(value, current.left);\n    } else if (value > current.data) {\n      return find(value, current.right);\n    }\n  }\n\n  function levelOrder(func) {\n    if (!func) {\n      var output = [];\n    }\n    let queue = [this.root];\n    function enqueueChildren(node) {\n      if (node.left) queue.push(node.left);\n      if (node.right) queue.push(node.right);\n    }\n    function processNode(node) {\n      enqueueChildren(node);\n      if (!func) {\n        output.push(node.data);\n      } else func(node.data);\n    }\n    while (queue.length > 0) {\n      let node = queue.shift();\n      processNode(node);\n    }\n    if (!func) {\n      console.log(`LevelOrder: ${output}`);\n    }\n  }\n\n  function inOrder(current = this.root, func, output = []) {\n    if (current === null) {\n      return\n    }\n    inOrder(current.left, func, output);\n    func ? func(current) : output.push(current.data);\n    inOrder(current.right, func, output);\n\n    if (output.length > 0) return output;\n  }\n\n  function preOrder(current, func, output = []) {\n    if (current === null) return;\n    func ? func(current) : output.push(current.data);\n    preOrder(current.left, func, output);\n    preOrder(current.right, func, output);\n    if (output.length > 0) return output;\n  }\n\n  function postOrder(current, func, output = []) {\n    if (current === null) return;\n    postOrder(current.left, func, output);\n    postOrder(current.right, func, output);\n    func ? func(current) : output.push(current.data);\n    if (output.length > 0) return output;\n  }\n\n  function height(current = root) {\n    if (current === null) return -1;\n\n    let leftHeight = height(current.left);\n    let rightHeight = height(current.right);\n\n    return leftHeight > rightHeight ? leftHeight + 1 : rightHeight + 1;\n  }\n\n  function depth(node, root = this.root, depthCount = 0) {\n    if (root === null || node === null) return;\n    if (node === root) {\n      console.log(depthCount);\n      return depthCount;\n    }\n    if (node.data < root.data) {\n      return depth(node, root.left, depthCount + 1);\n    } else {\n      return depth(node, root.right, depthCount + 1);\n    }\n  }\n\n  function isBalanced() {\n    let leftHeight = height(root.left)\n    let rightHeight = height(root.right)\n    if (Math.abs(leftHeight - rightHeight) > 1) {\n      return false\n    }\n    return true \n  }\n\n  function rebalance() {\n    let orderedArr = this.inOrder()\n    return buildTree(orderedArr, 0, orderedArr.length - 1);\n  }\n\n  return {\n    root,\n    insertNode,\n    deleteNode,\n    find,\n    levelOrder,\n    inOrder,\n    preOrder,\n    postOrder,\n    height,\n    depth,\n    isBalanced,\n    rebalance,\n  };\n}\n\n// function prettyPrint(node, prefix = \"\", isLeft = true) {\n//   if (node.right !== null) {\n//     prettyPrint(node.right, `${prefix}${isLeft ? \"│   \" : \"    \"}`, false);\n//   }\n//   console.log(`${prefix}${isLeft ? \"└── \" : \"┌── \"}${node.data}`);\n//   if (node.left !== null) {\n//     prettyPrint(node.left, `${prefix}${isLeft ? \"    \" : \"│   \"}`, true);\n//   }\n// }\n"],"names":[],"sourceRoot":""}